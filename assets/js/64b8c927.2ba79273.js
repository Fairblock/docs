"use strict";(self.webpackChunkfairblock_docusaurus=self.webpackChunkfairblock_docusaurus||[]).push([[3062],{4645:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>h,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=t(1527),a=t(7214);const i={sidebar_position:4},s="Keyshares and Aggregation",o={id:"learn/v1_details/network/keyshares_and_aggregation",title:"Keyshares and Aggregation",description:"Keyshares",source:"@site/docs/learn/v1_details/network/keyshares_and_aggregation.md",sourceDirName:"learn/v1_details/network",slug:"/learn/v1_details/network/keyshares_and_aggregation",permalink:"/docs/learn/v1_details/network/keyshares_and_aggregation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Public Keys and Encrypting Transactions",permalink:"/docs/learn/v1_details/network/pub_keys_and_encryption"},next:{title:"Transaction Decryption and Execution",permalink:"/docs/learn/v1_details/network/decrypt_and_execute"}},h={},c=[{value:"Keyshares",id:"keyshares",level:2},{value:"Keyshare Aggregation",id:"keyshare-aggregation",level:2}];function d(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"keyshares-and-aggregation",children:"Keyshares and Aggregation"}),"\n",(0,n.jsx)(r.h2,{id:"keyshares",children:"Keyshares"}),"\n",(0,n.jsxs)(r.p,{children:["Each MPK is derived from a Master Secret Key (MSK), which is generated each epoch by the ",(0,n.jsx)(r.a,{href:"../running-a-node/share_generation_client.md",children:"Share Generation Client"}),".\nOnce the MSK is generated, the ",(0,n.jsx)(r.a,{href:"../running-a-node/share_generation_client.md",children:"Share Generation Client"})," then performs a function to"]}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsx)(r.li,{children:"Derive the MPK"}),"\n",(0,n.jsx)(r.li,{children:"Splits up the MSK into individual keyshares encrypted by each validator's public key"}),"\n",(0,n.jsxs)(r.li,{children:["Submits the encrypted keyshares along with the MPK to ",(0,n.jsx)(r.code,{children:"fairyring"})]}),"\n",(0,n.jsx)(r.li,{children:"Discards the full MSK."}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["Each validator stores its share of the MSK locally and uses the ",(0,n.jsx)(r.a,{href:"../running-a-node/submit_keyshare.md#fairyringclient",children:(0,n.jsx)(r.code,{children:"fairyringclient"})}),"\nto derive the private keyshare for each block height corresponding to the ",(0,n.jsx)(r.code,{children:"ActivePubKey"}),".\nAfter the private keyshare is generated, the validator submits it via a transaction to ",(0,n.jsx)(r.code,{children:"fairyring"}),".\n",(0,n.jsx)(r.code,{children:"fairyring"})," aggregates the private keyshares, and when the threshold for private key construction is met, derives the private key for the current block height."]}),"\n",(0,n.jsxs)(r.p,{children:["Each validator needs to run the ",(0,n.jsx)(r.code,{children:"fairyringclient"})," in order to receive their MSK share each time it changes,\nderive their private keyshare according to the ",(0,n.jsx)(r.code,{children:"ActivePubKey"})," for each condition,\nand then submit the private keyshare to ",(0,n.jsx)(r.code,{children:"fairyring"})," for private key construction."]}),"\n",(0,n.jsxs)(r.p,{children:["The initial release will be a Proof of Authority (PoA) chain similar to the approach used by ",(0,n.jsx)(r.a,{href:"https://github.com/strangelove-ventures/noble",children:"Noble"}),".\nThere are some simple slashing conditions implemented for now (such as submitting incorrect keyshares, or skipping blocks), but this may change."]}),"\n",(0,n.jsx)(r.h2,{id:"keyshare-aggregation",children:"Keyshare Aggregation"}),"\n",(0,n.jsxs)(r.p,{children:["The key share aggregation process is made possible through threshold cryptography.\nOnce enough validators have submitted keyshares for a particular block,\nthe keyshares are aggregated to generate the derived private key for that block.\nThe derived private key can then be used to decrypt all encrypted transactions under a certain condition and execute them.\nTo create the aggregated keyshare, it is not required for every validator to submit their individual keyshares.\nThe aggregation can be performed as long as a threshold number of keyshares are submitted.\nCurrently, at least ",(0,n.jsx)(r.code,{children:"2/3 + 1"})," of the validators have to submit keyshares to create the aggregated keyshare."]})]})}function l(e={}){const{wrapper:r}={...(0,a.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},7214:(e,r,t)=>{t.d(r,{Z:()=>o,a:()=>s});var n=t(959);const a={},i=n.createContext(a);function s(e){const r=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);