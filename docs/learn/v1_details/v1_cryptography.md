---
sidebar_position: 1
---

# v1 Cryptography

Fairblock v1 mainly focuses on using Threshold Condition ID Based Encryption (tIBE) for its services as a chain. After reading this section you will understand:

1. What is IBE and tIBE
2. What basic functions are exposed to chains and Apps integrating with Fairblock

## Condition ID Based Encryption (IBE)

IBE is an encryption method where a user's public key is derived from a unique Condition ID (ID). A main reason Fairblock uses this encryption method is to have encryption and decryption capabilities that do not require certificates issued by some governing authority to validate a user's public key. Instead, a private key is generated by a trusted authority, in this case the `fairyring` chain and its decentralized validators. Each private key corresponds to a user's ID-based public key.

The above can be described in three equations.

### Encryption:

- Done with a function, called `encrypt()`.
- A user wants to encrypt their transaction, `m`, to later be decrypted and executed at a specific block height.
- The encrypted output will be represented by `c`.
- A unique `id` will be obtained from Fairyring.
<!-- TODO - confirm where id comes from -->

$$
encrypt(m, id) = c
$$

### Decryption Key Extraction

- Done with a function, called `extract()`.
- Uses `id` to derive a decryption key, `pk`, to decrypt the respective encrypted transaction.

$$
extract(id) = pk
$$

### Decryption Using the Decryption Key

- Done with a function, called `decrypt()`.
- Uses encrypted transaction (ciphertext), `c`, and decryption key, `pk`, to obtain the original transaction details, `m`.

$$
decrypt(c,pk) = m
$$

> Altogether, one can see that the following property holds true when using IBE.

$$
decrypt(encrypt(m, id), extract(id)) = m
$$

## Threshold IBE (tIBE)

The `fairyring` chain not only provides the capabilities to encrypt, decrypt, and communicate with inherent apps on its chain, and destination chains, but it also does so in a decentralized way. It does this by splitting up the master secret key amongst it's decentralized validator set and in order to obtain the respective decryption key, a threshold, `t`, of validators need to present their parts of said key; explaining the term Threshold IBE.

At a high-level, this is done through Lagrange interpolation, where the secret key can be mathetmatically derived.

Let's say that `a_0` below is the secret key, to derive it we will need a threshold amount of parts to properly interpolate what it is.

<!-- TODO - better elaborate on the equation below's relevance. -->

$$
p(x) = a_0 + a_1 x + a_2 x^2 + \dots + a_(t+1) x^(t)
$$

<!-- TODO need to fix above equation but t import giving issues on build -->

This is done by having each validator take n parts of the master secret key every epoch, where a threshold, `t`, amount of validators need to present their part of the key to aggregate the resultant master secret key.
